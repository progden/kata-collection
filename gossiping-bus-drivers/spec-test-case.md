# Gossiping Bus Drivers 規格與測試案例

## 問題描述

公車司機們喜歡交換八卦，每當他們在公車站相遇時，會互相分享所知道的所有八卦。
每位司機在一天開始時都有一則八卦要分享。
目標是找出需要多少分鐘才能讓所有司機知道所有八卦。

---

## 規則

| 規則 | 說明 |
|------|------|
| 1 | 每位司機有固定路線，循環行駛 |
| 2 | 每位司機一開始擁有一則獨特的八卦 |
| 3 | 分鐘 1 = 在第一站，分鐘 2 = 在第二站，依此類推 |
| 4 | 當司機在同一站相遇時，會立即分享所有已知的八卦 |
| 5 | 工作日上限為 480 分鐘 |
| 6 | 若無法在時限內完成，回傳 "never" |

---

## API 介面

```java
// 建立路線（整行數字都是站牌）
Route route = Route.of(3, 1, 2, 3);  // 站牌序列 [3, 1, 2, 3]

// 計算結果
GossipingBusDrivers solver = new GossipingBusDriversSimulation();
GossipResult result = solver.calculate(List.of(route1, route2, route3));

// 取得結果
result.isSuccess();   // true 或 false
result.toString();    // "5" 或 "never"
result.minutes();     // Optional<Integer>
```

---

## 三種實作方式

| 實作 | 類別名稱 | 說明 |
|------|----------|------|
| 模擬法 | `GossipingBusDriversSimulation` | 逐分鐘模擬，O(480 * n²) |
| 事件驅動 | `GossipingBusDriversEventDriven` | 只處理相遇事件，O(E * n) |
| 圖論法 | `GossipingBusDriversGraph` | 預計算相遇時間，O(n² * LCM + M * n) |

---

## 測試案例 (ZOMBIES 順序)

### Zero - 零或最小情境

| 場景 | 輸入路線 | 預期輸出 | 原因 |
|------|----------|----------|------|
| 只有一位司機 | `[[1,2,3]]` | `1` | 無需交換，第 1 分鐘即完成 |
| 空路線清單 | `[]` | `1` | 無司機，視為已完成 |

### One - 單一情境

| 場景 | 輸入路線 | 預期輸出 | 原因 |
|------|----------|----------|------|
| 兩位司機第一站相遇 | `[[1,2,3], [1,3,4]]` | `1` | 第 1 分鐘在站 1 相遇 |
| 兩位司機第二站相遇 | `[[1,2,3], [5,2,4]]` | `2` | 第 2 分鐘在站 2 相遇 |
| 需要循環才相遇 | `[[1,2], [3,2]]` | `2` | 第 2 分鐘在站 2 相遇 |

### Many - 多重情境

| 場景 | 輸入路線 | 預期輸出 | 原因 |
|------|----------|----------|------|
| 範例一 | `[[3,1,2,3], [3,2,3,1], [4,2,3,4,5]]` | `5` | 需要多次相遇和傳播 |
| 三人同時相遇 | `[[1,2,3], [1,4,5], [1,6,7]]` | `1` | 第 1 分鐘三人都在站 1 |

### Boundary - 邊界情境

| 場景 | 輸入路線 | 預期輸出 | 原因 |
|------|----------|----------|------|
| 路線長度為 1 且同站 | `[[1], [1]]` | `1` | 永遠在同一站 |
| 路線長度為 1 且不同站 | `[[1], [2]]` | `never` | 永遠不會相遇 |
| 永不相交的路線 | `[[1,2], [3,4]]` | `never` | 路線無交集 |

### Exception - 例外情境

| 場景 | 輸入路線 | 預期輸出 | 原因 |
|------|----------|----------|------|
| 範例二 | `[[1,2], [2,8]]` | `never` | 在 480 分鐘內無法完成 |
| 部分司機無法相遇 | `[[1,2], [1,3], [5,6]]` | `never` | 司機 C 與 A,B 無交集 |
| 空路線 | `Route.of()` | 拋出例外 | 路線不可為空 |

---

## 範例詳解

### 範例一：三位司機

```
輸入路線（整行都是站牌）：
司機 A: 3 1 2 3   -> 路線 [3, 1, 2, 3]
司機 B: 3 2 3 1   -> 路線 [3, 2, 3, 1]
司機 C: 4 2 3 4 5 -> 路線 [4, 2, 3, 4, 5]

時間軸分析：
M1: A@3, B@3, C@4  → A-B 相遇，A={A,B}, B={A,B}
M2: A@1, B@2, C@2  → B-C 相遇，B={A,B,C}, C={A,B,C}
M3: A@2, B@3, C@3  → B-C 相遇（無新八卦）
M4: A@3, B@1, C@4  → 無相遇
M5: A@3, B@3, C@5  → A-B 相遇，A={A,B,C}

答案：5（所有司機知道全部八卦）
```

### 範例二：永不完成

```
輸入路線：
司機 A: [1, 2]
司機 B: [2, 8]

分析：
- A 訪問站牌：{1, 2}
- B 訪問站牌：{2, 8}
- 共同站牌：{2}

但檢查發現 A 和 B 在 480 分鐘內從未同時在站 2：
- A 在站 2 的時間：2, 4, 6, 8, ...（偶數分鐘）
- B 在站 2 的時間：1, 3, 5, 7, ...（奇數分鐘）

答案：never
```

---

## Route 循環計算

```java
// 取得分鐘 m 時的站牌
public int getStopAt(int minute) {
    int index = (minute - 1) % stops.length();
    return stops.get(index);
}

// 範例：路線 [3, 1, 2, 3]
// 分鐘 1 -> index 0 -> 站 3
// 分鐘 2 -> index 1 -> 站 1
// 分鐘 3 -> index 2 -> 站 2
// 分鐘 4 -> index 3 -> 站 3
// 分鐘 5 -> index 0 -> 站 3（循環）
```
